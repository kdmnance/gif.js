// Generated by CommonJS Everywhere 0.9.7
(function (global) {
  function require(file, parentModule) {
    if ({}.hasOwnProperty.call(require.cache, file))
      return require.cache[file];
    var resolved = require.resolve(file);
    if (!resolved)
      throw new Error('Failed to resolve module ' + file);
    var module$ = {
        id: file,
        require: require,
        filename: file,
        exports: {},
        loaded: false,
        parent: parentModule,
        children: []
      };
    if (parentModule)
      parentModule.children.push(module$);
    var dirname = file.slice(0, file.lastIndexOf('/') + 1);
    require.cache[file] = module$.exports;
    resolved.call(module$.exports, module$, module$.exports, dirname, file);
    module$.loaded = true;
    return require.cache[file] = module$.exports;
  }
  require.modules = {};
  require.cache = {};
  require.resolve = function (file) {
    return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;
  };
  require.define = function (file, fn) {
    require.modules[file] = fn;
  };
  require.define('/gif.worker.coffee', function (module, exports, __dirname, __filename) {
    var GIFEncoder, renderFrame;
    GIFEncoder = require('/GIFEncoder.js', module);
    renderFrame = function (frame) {
      var encoder, page, stream, transfer;
      encoder = new GIFEncoder(frame.width, frame.height);
      if (frame.index === 0) {
        encoder.writeHeader();
      } else {
        encoder.firstFrame = false;
      }
      encoder.setTransparent(frame.transparent);
      encoder.setRepeat(frame.repeat);
      encoder.setDelay(frame.delay);
      encoder.setQuality(frame.quality);
      encoder.setDither(frame.dither);
      encoder.setGlobalPalette(frame.globalPalette);
      encoder.addFrame(frame.data);
      if (frame.last)
        encoder.finish();
      if (frame.globalPalette === true)
        frame.globalPalette = encoder.getGlobalPalette();
      stream = encoder.stream();
      frame.data = stream.pages;
      frame.cursor = stream.cursor;
      frame.pageSize = stream.constructor.pageSize;
      if (frame.canTransfer) {
        transfer = function (accum$) {
          for (var i$ = 0, length$ = frame.data.length; i$ < length$; ++i$) {
            page = frame.data[i$];
            accum$.push(page.buffer);
          }
          return accum$;
        }.call(this, []);
        return self.postMessage(frame, transfer);
      } else {
        return self.postMessage(frame);
      }
    };
    self.onmessage = function (event) {
      return renderFrame(event.data);
    };
  });
  require.define('/GIFEncoder.js', function (module, exports, __dirname, __filename) {
    var NeuQuant = require('/rgbquant.js', module);
    var LZWEncoder = require('/LZWEncoder.js', module);
    function ByteArray() {
      this.page = -1;
      this.pages = [];
      this.newPage();
    }
    ByteArray.pageSize = 4096;
    ByteArray.charMap = {};
    for (var i = 0; i < 256; i++)
      ByteArray.charMap[i] = String.fromCharCode(i);
    ByteArray.prototype.newPage = function () {
      this.pages[++this.page] = new Uint8Array(ByteArray.pageSize);
      this.cursor = 0;
    };
    ByteArray.prototype.getData = function () {
      var rv = '';
      for (var p = 0; p < this.pages.length; p++) {
        for (var i = 0; i < ByteArray.pageSize; i++) {
          rv += ByteArray.charMap[this.pages[p][i]];
        }
      }
      return rv;
    };
    ByteArray.prototype.writeByte = function (val) {
      if (this.cursor >= ByteArray.pageSize)
        this.newPage();
      this.pages[this.page][this.cursor++] = val;
    };
    ByteArray.prototype.writeUTFBytes = function (string) {
      for (var l = string.length, i = 0; i < l; i++)
        this.writeByte(string.charCodeAt(i));
    };
    ByteArray.prototype.writeBytes = function (array, offset, length) {
      for (var l = length || array.length, i = offset || 0; i < l; i++)
        this.writeByte(array[i]);
    };
    function GIFEncoder(width, height) {
      this.width = ~~width;
      this.height = ~~height;
      this.transparent = null;
      this.transIndex = 0;
      this.repeat = -1;
      this.delay = 0;
      this.image = null;
      this.pixels = null;
      this.indexedPixels = null;
      this.colorDepth = null;
      this.colorTab = null;
      this.usedEntry = new Array;
      this.palSize = 7;
      this.dispose = -1;
      this.firstFrame = true;
      this.sample = 10;
      this.dither = false;
      this.globalPalette = false;
      this.out = new ByteArray;
    }
    GIFEncoder.prototype.setDelay = function (milliseconds) {
      this.delay = Math.round(milliseconds / 10);
    };
    GIFEncoder.prototype.setFrameRate = function (fps) {
      this.delay = Math.round(100 / fps);
    };
    GIFEncoder.prototype.setDispose = function (disposalCode) {
      if (disposalCode >= 0)
        this.dispose = disposalCode;
    };
    GIFEncoder.prototype.setRepeat = function (repeat) {
      this.repeat = repeat;
    };
    GIFEncoder.prototype.setTransparent = function (color) {
      this.transparent = color;
    };
    GIFEncoder.prototype.addFrame = function (imageData) {
      this.image = imageData;
      this.colorTab = this.globalPalette ? this.globalPalette : null;
      this.getImagePixels();
      this.analyzePixels();
      if (this.globalPalette === true)
        this.globalPalette = this.colorTab;
      if (this.firstFrame) {
        this.writeLSD();
        this.writePalette();
        if (this.repeat >= 0) {
          this.writeNetscapeExt();
        }
      }
      this.writeGraphicCtrlExt();
      this.writeImageDesc();
      if (!this.firstFrame && !this.globalPalette)
        this.writePalette();
      this.writePixels();
      this.firstFrame = false;
    };
    GIFEncoder.prototype.finish = function () {
      this.out.writeByte(59);
    };
    GIFEncoder.prototype.setQuality = function (quality) {
      if (quality < 1)
        quality = 1;
      this.sample = quality;
    };
    GIFEncoder.prototype.setDither = function (dither) {
      if (dither === true)
        dither = 'FloydSteinberg';
      this.dither = dither;
    };
    GIFEncoder.prototype.setGlobalPalette = function (palette) {
      this.globalPalette = palette;
    };
    GIFEncoder.prototype.getGlobalPalette = function () {
      return this.globalPalette && this.globalPalette.slice(0) || this.globalPalette;
    };
    GIFEncoder.prototype.writeHeader = function () {
      this.out.writeUTFBytes('GIF89a');
    };
    GIFEncoder.prototype.analyzePixels = function () {
      if (!this.colorTab) {
        var imgq = new NeuQuant(this.pixels, this.sample);
        imgq.buildColormap();
        this.colorTab = imgq.getColormap();
      }
      if (this.dither) {
        this.ditherPixels(this.dither.replace('-serpentine', ''), this.dither.match(/-serpentine/) !== null);
      } else {
        this.indexPixels();
      }
      this.pixels = null;
      this.colorDepth = 8;
      this.palSize = 7;
      if (this.transparent !== null) {
        this.transIndex = this.findClosest(this.transparent, true);
      }
    };
    GIFEncoder.prototype.indexPixels = function (imgq) {
      var nPix = this.pixels.length / 3;
      this.indexedPixels = new Uint8Array(nPix);
      var k = 0;
      for (var j = 0; j < nPix; j++) {
        var index = this.findClosestRGB(this.pixels[k++] & 255, this.pixels[k++] & 255, this.pixels[k++] & 255);
        this.usedEntry[index] = true;
        this.indexedPixels[j] = index;
      }
    };
    GIFEncoder.prototype.ditherPixels = function (kernel, serpentine) {
      var kernels = {
          FalseFloydSteinberg: [
            [
              3 / 8,
              1,
              0
            ],
            [
              3 / 8,
              0,
              1
            ],
            [
              2 / 8,
              1,
              1
            ]
          ],
          FloydSteinberg: [
            [
              7 / 16,
              1,
              0
            ],
            [
              3 / 16,
              -1,
              1
            ],
            [
              5 / 16,
              0,
              1
            ],
            [
              1 / 16,
              1,
              1
            ]
          ],
          Stucki: [
            [
              8 / 42,
              1,
              0
            ],
            [
              4 / 42,
              2,
              0
            ],
            [
              2 / 42,
              -2,
              1
            ],
            [
              4 / 42,
              -1,
              1
            ],
            [
              8 / 42,
              0,
              1
            ],
            [
              4 / 42,
              1,
              1
            ],
            [
              2 / 42,
              2,
              1
            ],
            [
              1 / 42,
              -2,
              2
            ],
            [
              2 / 42,
              -1,
              2
            ],
            [
              4 / 42,
              0,
              2
            ],
            [
              2 / 42,
              1,
              2
            ],
            [
              1 / 42,
              2,
              2
            ]
          ],
          Atkinson: [
            [
              1 / 8,
              1,
              0
            ],
            [
              1 / 8,
              2,
              0
            ],
            [
              1 / 8,
              -1,
              1
            ],
            [
              1 / 8,
              0,
              1
            ],
            [
              1 / 8,
              1,
              1
            ],
            [
              1 / 8,
              0,
              2
            ]
          ]
        };
      if (!kernel || !kernels[kernel]) {
        throw 'Unknown dithering kernel: ' + kernel;
      }
      var ds = kernels[kernel];
      var index = 0, height = this.height, width = this.width, data = this.pixels;
      var direction = serpentine ? -1 : 1;
      this.indexedPixels = new Uint8Array(this.pixels.length / 3);
      for (var y = 0; y < height; y++) {
        if (serpentine)
          direction = direction * -1;
        for (var x = direction == 1 ? 0 : width - 1, xend = direction == 1 ? width : 0; x !== xend; x += direction) {
          index = y * width + x;
          var idx = index * 3;
          var r1 = data[idx];
          var g1 = data[idx + 1];
          var b1 = data[idx + 2];
          idx = this.findClosestRGB(r1, g1, b1);
          this.usedEntry[idx] = true;
          this.indexedPixels[index] = idx;
          idx *= 3;
          var r2 = this.colorTab[idx];
          var g2 = this.colorTab[idx + 1];
          var b2 = this.colorTab[idx + 2];
          var er = r1 - r2;
          var eg = g1 - g2;
          var eb = b1 - b2;
          for (var i = direction == 1 ? 0 : ds.length - 1, end = direction == 1 ? ds.length : 0; i !== end; i += direction) {
            var x1 = ds[i][1];
            var y1 = ds[i][2];
            if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
              var d = ds[i][0];
              idx = index + x1 + y1 * width;
              idx *= 3;
              data[idx] = Math.max(0, Math.min(255, data[idx] + er * d));
              data[idx + 1] = Math.max(0, Math.min(255, data[idx + 1] + eg * d));
              data[idx + 2] = Math.max(0, Math.min(255, data[idx + 2] + eb * d));
            }
          }
        }
      }
    };
    GIFEncoder.prototype.findClosest = function (c, used) {
      return this.findClosestRGB((c & 16711680) >> 16, (c & 65280) >> 8, c & 255, used);
    };
    GIFEncoder.prototype.findClosestRGB = function (r, g, b, used) {
      if (this.colorTab === null)
        return -1;
      var c = b | g << 8 | r << 16;
      var minpos = 0;
      var dmin = 256 * 256 * 256;
      var len = this.colorTab.length;
      for (var i = 0; i < len;) {
        var dr = r - (this.colorTab[i++] & 255);
        var dg = g - (this.colorTab[i++] & 255);
        var db = b - (this.colorTab[i] & 255);
        var d = dr * dr + dg * dg + db * db;
        var index = parseInt(i / 3);
        if ((!used || this.usedEntry[index]) && d < dmin) {
          dmin = d;
          minpos = index;
        }
        i++;
      }
      return minpos;
    };
    GIFEncoder.prototype.getImagePixels = function () {
      var w = this.width;
      var h = this.height;
      this.pixels = new Uint8Array(w * h * 3);
      var data = this.image;
      var count = 0;
      for (var i = 0; i < h; i++) {
        for (var j = 0; j < w; j++) {
          var b = i * w * 4 + j * 4;
          this.pixels[count++] = data[b];
          this.pixels[count++] = data[b + 1];
          this.pixels[count++] = data[b + 2];
        }
      }
    };
    GIFEncoder.prototype.writeGraphicCtrlExt = function () {
      this.out.writeByte(33);
      this.out.writeByte(249);
      this.out.writeByte(4);
      var transp, disp;
      if (this.transparent === null) {
        transp = 0;
        disp = 0;
      } else {
        transp = 1;
        disp = 2;
      }
      if (this.dispose >= 0) {
        disp = dispose & 7;
      }
      disp <<= 2;
      this.out.writeByte(0 | disp | 0 | transp);
      this.writeShort(this.delay);
      this.out.writeByte(this.transIndex);
      this.out.writeByte(0);
    };
    GIFEncoder.prototype.writeImageDesc = function () {
      this.out.writeByte(44);
      this.writeShort(0);
      this.writeShort(0);
      this.writeShort(this.width);
      this.writeShort(this.height);
      if (this.firstFrame || this.globalPalette) {
        this.out.writeByte(0);
      } else {
        this.out.writeByte(128 | 0 | 0 | 0 | this.palSize);
      }
    };
    GIFEncoder.prototype.writeLSD = function () {
      this.writeShort(this.width);
      this.writeShort(this.height);
      this.out.writeByte(128 | 112 | 0 | this.palSize);
      this.out.writeByte(0);
      this.out.writeByte(0);
    };
    GIFEncoder.prototype.writeNetscapeExt = function () {
      this.out.writeByte(33);
      this.out.writeByte(255);
      this.out.writeByte(11);
      this.out.writeUTFBytes('NETSCAPE2.0');
      this.out.writeByte(3);
      this.out.writeByte(1);
      this.writeShort(this.repeat);
      this.out.writeByte(0);
    };
    GIFEncoder.prototype.writePalette = function () {
      this.out.writeBytes(this.colorTab);
      var n = 3 * 256 - this.colorTab.length;
      for (var i = 0; i < n; i++)
        this.out.writeByte(0);
    };
    GIFEncoder.prototype.writeShort = function (pValue) {
      this.out.writeByte(pValue & 255);
      this.out.writeByte(pValue >> 8 & 255);
    };
    GIFEncoder.prototype.writePixels = function () {
      var enc = new LZWEncoder(this.width, this.height, this.indexedPixels, this.colorDepth);
      enc.encode(this.out);
    };
    GIFEncoder.prototype.stream = function () {
      return this.out;
    };
    module.exports = GIFEncoder;
  });
  require.define('/LZWEncoder.js', function (module, exports, __dirname, __filename) {
    var EOF = -1;
    var BITS = 12;
    var HSIZE = 5003;
    var masks = [
        0,
        1,
        3,
        7,
        15,
        31,
        63,
        127,
        255,
        511,
        1023,
        2047,
        4095,
        8191,
        16383,
        32767,
        65535
      ];
    function LZWEncoder(width, height, pixels, colorDepth) {
      var initCodeSize = Math.max(2, colorDepth);
      var accum = new Uint8Array(256);
      var htab = new Int32Array(HSIZE);
      var codetab = new Int32Array(HSIZE);
      var cur_accum, cur_bits = 0;
      var a_count;
      var free_ent = 0;
      var maxcode;
      var clear_flg = false;
      var g_init_bits, ClearCode, EOFCode;
      function char_out(c, outs) {
        accum[a_count++] = c;
        if (a_count >= 254)
          flush_char(outs);
      }
      function cl_block(outs) {
        cl_hash(HSIZE);
        free_ent = ClearCode + 2;
        clear_flg = true;
        output(ClearCode, outs);
      }
      function cl_hash(hsize) {
        for (var i = 0; i < hsize; ++i)
          htab[i] = -1;
      }
      function compress(init_bits, outs) {
        var fcode, c, i, ent, disp, hsize_reg, hshift;
        g_init_bits = init_bits;
        clear_flg = false;
        n_bits = g_init_bits;
        maxcode = MAXCODE(n_bits);
        ClearCode = 1 << init_bits - 1;
        EOFCode = ClearCode + 1;
        free_ent = ClearCode + 2;
        a_count = 0;
        ent = nextPixel();
        hshift = 0;
        for (fcode = HSIZE; fcode < 65536; fcode *= 2)
          ++hshift;
        hshift = 8 - hshift;
        hsize_reg = HSIZE;
        cl_hash(hsize_reg);
        output(ClearCode, outs);
        outer_loop:
          while ((c = nextPixel()) != EOF) {
            fcode = (c << BITS) + ent;
            i = c << hshift ^ ent;
            if (htab[i] === fcode) {
              ent = codetab[i];
              continue;
            } else if (htab[i] >= 0) {
              disp = hsize_reg - i;
              if (i === 0)
                disp = 1;
              do {
                if ((i -= disp) < 0)
                  i += hsize_reg;
                if (htab[i] === fcode) {
                  ent = codetab[i];
                  continue outer_loop;
                }
              } while (htab[i] >= 0);
            }
            output(ent, outs);
            ent = c;
            if (free_ent < 1 << BITS) {
              codetab[i] = free_ent++;
              htab[i] = fcode;
            } else {
              cl_block(outs);
            }
          }
        output(ent, outs);
        output(EOFCode, outs);
      }
      function encode(outs) {
        outs.writeByte(initCodeSize);
        remaining = width * height;
        curPixel = 0;
        compress(initCodeSize + 1, outs);
        outs.writeByte(0);
      }
      function flush_char(outs) {
        if (a_count > 0) {
          outs.writeByte(a_count);
          outs.writeBytes(accum, 0, a_count);
          a_count = 0;
        }
      }
      function MAXCODE(n_bits) {
        return (1 << n_bits) - 1;
      }
      function nextPixel() {
        if (remaining === 0)
          return EOF;
        --remaining;
        var pix = pixels[curPixel++];
        return pix & 255;
      }
      function output(code, outs) {
        cur_accum &= masks[cur_bits];
        if (cur_bits > 0)
          cur_accum |= code << cur_bits;
        else
          cur_accum = code;
        cur_bits += n_bits;
        while (cur_bits >= 8) {
          char_out(cur_accum & 255, outs);
          cur_accum >>= 8;
          cur_bits -= 8;
        }
        if (free_ent > maxcode || clear_flg) {
          if (clear_flg) {
            maxcode = MAXCODE(n_bits = g_init_bits);
            clear_flg = false;
          } else {
            ++n_bits;
            if (n_bits == BITS)
              maxcode = 1 << BITS;
            else
              maxcode = MAXCODE(n_bits);
          }
        }
        if (code == EOFCode) {
          while (cur_bits > 0) {
            char_out(cur_accum & 255, outs);
            cur_accum >>= 8;
            cur_bits -= 8;
          }
          flush_char(outs);
        }
      }
      this.encode = encode;
    }
    module.exports = LZWEncoder;
  });
  require.define('/rgbquant.js', function (module, exports, __dirname, __filename) {
    (function () {
      function RgbQuant(opts) {
        opts = opts || {};
        this.method = opts.method || 2;
        this.colors = opts.colors || 256;
        this.initColors = opts.initColors || 4096;
        this.initDist = opts.initDist || .01;
        this.distIncr = opts.distIncr || .005;
        this.hueGroups = opts.hueGroups || 10;
        this.satGroups = opts.satGroups || 10;
        this.lumGroups = opts.lumGroups || 10;
        this.minHueCols = opts.minHueCols || 0;
        this.hueStats = this.minHueCols ? new HueStats(this.hueGroups, this.minHueCols) : null;
        this.boxSize = opts.boxSize || [
          64,
          64
        ];
        this.boxPxls = opts.boxPxls || 2;
        this.palLocked = false;
        this.dithKern = opts.dithKern || null;
        this.dithSerp = opts.dithSerp || false;
        this.dithDelta = opts.dithDelta || 0;
        this.histogram = {};
        this.idxrgb = opts.palette ? opts.palette.slice(0) : [];
        this.idxi32 = [];
        this.i32idx = {};
        this.i32rgb = {};
        this.useCache = opts.useCache !== false;
        this.cacheFreq = opts.cacheFreq || 10;
        this.reIndex = opts.reIndex || this.idxrgb.length == 0;
        this.colorDist = opts.colorDist == 'manhattan' ? distManhattan : distEuclidean;
        if (this.idxrgb.length > 0) {
          var self = this;
          this.idxrgb.forEach(function (rgb, i) {
            var i32 = (255 << 24 | rgb[2] << 16 | rgb[1] << 8 | rgb[0]) >>> 0;
            self.idxi32[i] = i32;
            self.i32idx[i32] = i;
            self.i32rgb[i32] = rgb;
          });
        }
      }
      RgbQuant.prototype.sample = function sample(img, width) {
        if (this.palLocked)
          throw 'Cannot sample additional images, palette already assembled.';
        var data = getImageData(img, width);
        switch (this.method) {
        case 1:
          this.colorStats1D(data.buf32);
          break;
        case 2:
          this.colorStats2D(data.buf32, data.width);
          break;
        }
      };
      RgbQuant.prototype.reduce = function reduce(img, retType, dithKern, dithSerp) {
        if (!this.palLocked)
          this.buildPal();
        dithKern = dithKern || this.dithKern;
        dithSerp = typeof dithSerp != 'undefined' ? dithSerp : this.dithSerp;
        retType = retType || 1;
        if (dithKern)
          var out32 = this.dither(img, dithKern, dithSerp);
        else {
          var data = getImageData(img), buf32 = data.buf32, len = buf32.length, out32 = new Uint32Array(len);
          for (var i = 0; i < len; i++) {
            var i32 = buf32[i];
            out32[i] = this.nearestColor(i32);
          }
        }
        if (retType == 1)
          return new Uint8Array(out32.buffer);
        if (retType == 2) {
          var out = [], len = out32.length;
          for (var i = 0; i < len; i++) {
            var i32 = out32[i];
            out[i] = this.i32idx[i32];
          }
          return out;
        }
      };
      RgbQuant.prototype.dither = function (img, kernel, serpentine) {
        var kernels = {
            FloydSteinberg: [
              [
                7 / 16,
                1,
                0
              ],
              [
                3 / 16,
                -1,
                1
              ],
              [
                5 / 16,
                0,
                1
              ],
              [
                1 / 16,
                1,
                1
              ]
            ],
            FalseFloydSteinberg: [
              [
                3 / 8,
                1,
                0
              ],
              [
                3 / 8,
                0,
                1
              ],
              [
                2 / 8,
                1,
                1
              ]
            ],
            Stucki: [
              [
                8 / 42,
                1,
                0
              ],
              [
                4 / 42,
                2,
                0
              ],
              [
                2 / 42,
                -2,
                1
              ],
              [
                4 / 42,
                -1,
                1
              ],
              [
                8 / 42,
                0,
                1
              ],
              [
                4 / 42,
                1,
                1
              ],
              [
                2 / 42,
                2,
                1
              ],
              [
                1 / 42,
                -2,
                2
              ],
              [
                2 / 42,
                -1,
                2
              ],
              [
                4 / 42,
                0,
                2
              ],
              [
                2 / 42,
                1,
                2
              ],
              [
                1 / 42,
                2,
                2
              ]
            ],
            Atkinson: [
              [
                1 / 8,
                1,
                0
              ],
              [
                1 / 8,
                2,
                0
              ],
              [
                1 / 8,
                -1,
                1
              ],
              [
                1 / 8,
                0,
                1
              ],
              [
                1 / 8,
                1,
                1
              ],
              [
                1 / 8,
                0,
                2
              ]
            ],
            Jarvis: [
              [
                7 / 48,
                1,
                0
              ],
              [
                5 / 48,
                2,
                0
              ],
              [
                3 / 48,
                -2,
                1
              ],
              [
                5 / 48,
                -1,
                1
              ],
              [
                7 / 48,
                0,
                1
              ],
              [
                5 / 48,
                1,
                1
              ],
              [
                3 / 48,
                2,
                1
              ],
              [
                1 / 48,
                -2,
                2
              ],
              [
                3 / 48,
                -1,
                2
              ],
              [
                5 / 48,
                0,
                2
              ],
              [
                3 / 48,
                1,
                2
              ],
              [
                1 / 48,
                2,
                2
              ]
            ],
            Burkes: [
              [
                8 / 32,
                1,
                0
              ],
              [
                4 / 32,
                2,
                0
              ],
              [
                2 / 32,
                -2,
                1
              ],
              [
                4 / 32,
                -1,
                1
              ],
              [
                8 / 32,
                0,
                1
              ],
              [
                4 / 32,
                1,
                1
              ],
              [
                2 / 32,
                2,
                1
              ]
            ],
            Sierra: [
              [
                5 / 32,
                1,
                0
              ],
              [
                3 / 32,
                2,
                0
              ],
              [
                2 / 32,
                -2,
                1
              ],
              [
                4 / 32,
                -1,
                1
              ],
              [
                5 / 32,
                0,
                1
              ],
              [
                4 / 32,
                1,
                1
              ],
              [
                2 / 32,
                2,
                1
              ],
              [
                2 / 32,
                -1,
                2
              ],
              [
                3 / 32,
                0,
                2
              ],
              [
                2 / 32,
                1,
                2
              ]
            ],
            TwoSierra: [
              [
                4 / 16,
                1,
                0
              ],
              [
                3 / 16,
                2,
                0
              ],
              [
                1 / 16,
                -2,
                1
              ],
              [
                2 / 16,
                -1,
                1
              ],
              [
                3 / 16,
                0,
                1
              ],
              [
                2 / 16,
                1,
                1
              ],
              [
                1 / 16,
                2,
                1
              ]
            ],
            SierraLite: [
              [
                2 / 4,
                1,
                0
              ],
              [
                1 / 4,
                -1,
                1
              ],
              [
                1 / 4,
                0,
                1
              ]
            ]
          };
        if (!kernel || !kernels[kernel]) {
          throw 'Unknown dithering kernel: ' + kernel;
        }
        var ds = kernels[kernel];
        var data = getImageData(img), buf32 = data.buf32, width = data.width, height = data.height, len = buf32.length;
        var dir = serpentine ? -1 : 1;
        for (var y = 0; y < height; y++) {
          if (serpentine)
            dir = dir * -1;
          var lni = y * width;
          for (var x = dir == 1 ? 0 : width - 1, xend = dir == 1 ? width : 0; x !== xend; x += dir) {
            var idx = lni + x, i32 = buf32[idx], r1 = i32 & 255, g1 = (i32 & 65280) >> 8, b1 = (i32 & 16711680) >> 16;
            var i32x = this.nearestColor(i32), r2 = i32x & 255, g2 = (i32x & 65280) >> 8, b2 = (i32x & 16711680) >> 16;
            buf32[idx] = 255 << 24 | b2 << 16 | g2 << 8 | r2;
            if (this.dithDelta) {
              var dist = this.colorDist([
                  r1,
                  g1,
                  b1
                ], [
                  r2,
                  g2,
                  b2
                ]);
              if (dist < this.dithDelta)
                continue;
            }
            var er = r1 - r2, eg = g1 - g2, eb = b1 - b2;
            for (var i = dir == 1 ? 0 : ds.length - 1, end = dir == 1 ? ds.length : 0; i !== end; i += dir) {
              var x1 = ds[i][1] * dir, y1 = ds[i][2];
              var lni2 = y1 * width;
              if (x1 + x >= 0 && x1 + x < width && y1 + y >= 0 && y1 + y < height) {
                var d = ds[i][0];
                var idx2 = idx + (lni2 + x1);
                var r3 = buf32[idx2] & 255, g3 = (buf32[idx2] & 65280) >> 8, b3 = (buf32[idx2] & 16711680) >> 16;
                var r4 = Math.max(0, Math.min(255, r3 + er * d)), g4 = Math.max(0, Math.min(255, g3 + eg * d)), b4 = Math.max(0, Math.min(255, b3 + eb * d));
                buf32[idx2] = 255 << 24 | b4 << 16 | g4 << 8 | r4;
              }
            }
          }
        }
        return buf32;
      };
      RgbQuant.prototype.buildPal = function buildPal(noSort) {
        if (this.palLocked || this.idxrgb.length > 0 && this.idxrgb.length <= this.colors)
          return;
        var histG = this.histogram, sorted = sortedHashKeys(histG, true);
        if (sorted.length == 0)
          throw 'Nothing has been sampled, palette cannot be built.';
        switch (this.method) {
        case 1:
          var cols = this.initColors, last = sorted[cols - 1], freq = histG[last];
          var idxi32 = sorted.slice(0, cols);
          var pos = cols, len = sorted.length;
          while (pos < len && histG[sorted[pos]] == freq)
            idxi32.push(sorted[pos++]);
          if (this.hueStats)
            this.hueStats.inject(idxi32);
          break;
        case 2:
          var idxi32 = sorted;
          break;
        }
        idxi32 = idxi32.map(function (v) {
          return +v;
        });
        this.reducePal(idxi32);
        if (!noSort && this.reIndex)
          this.sortPal();
        if (this.useCache)
          this.cacheHistogram(idxi32);
        this.palLocked = true;
      };
      RgbQuant.prototype.palette = function palette(tuples, noSort) {
        this.buildPal(noSort);
        return tuples ? this.idxrgb : new Uint8Array(new Uint32Array(this.idxi32).buffer);
      };
      RgbQuant.prototype.prunePal = function prunePal(keep) {
        var i32;
        for (var j = 0; j < this.idxrgb.length; j++) {
          if (!keep[j]) {
            i32 = this.idxi32[j];
            this.idxrgb[j] = null;
            this.idxi32[j] = null;
            delete this.i32idx[i32];
          }
        }
        if (this.reIndex) {
          var idxrgb = [], idxi32 = [], i32idx = {};
          for (var j = 0, i = 0; j < this.idxrgb.length; j++) {
            if (this.idxrgb[j]) {
              i32 = this.idxi32[j];
              idxrgb[i] = this.idxrgb[j];
              i32idx[i32] = i;
              idxi32[i] = i32;
              i++;
            }
          }
          this.idxrgb = idxrgb;
          this.idxi32 = idxi32;
          this.i32idx = i32idx;
        }
      };
      RgbQuant.prototype.reducePal = function reducePal(idxi32) {
        if (this.idxrgb.length > this.colors) {
          var len = idxi32.length, keep = {}, uniques = 0, idx, pruned = false;
          for (var i = 0; i < len; i++) {
            if (uniques == this.colors && !pruned) {
              this.prunePal(keep);
              pruned = true;
            }
            idx = this.nearestIndex(idxi32[i]);
            if (uniques < this.colors && !keep[idx]) {
              keep[idx] = true;
              uniques++;
            }
          }
          if (!pruned) {
            this.prunePal(keep);
            pruned = true;
          }
        } else {
          var idxrgb = idxi32.map(function (i32) {
              return [
                i32 & 255,
                (i32 & 65280) >> 8,
                (i32 & 16711680) >> 16
              ];
            });
          var len = idxrgb.length, palLen = len, thold = this.initDist;
          if (palLen > this.colors) {
            while (palLen > this.colors) {
              var memDist = [];
              for (var i = 0; i < len; i++) {
                var pxi = idxrgb[i], i32i = idxi32[i];
                if (!pxi)
                  continue;
                for (var j = i + 1; j < len; j++) {
                  var pxj = idxrgb[j], i32j = idxi32[j];
                  if (!pxj)
                    continue;
                  var dist = this.colorDist(pxi, pxj);
                  if (dist < thold) {
                    memDist.push([
                      j,
                      pxj,
                      i32j,
                      dist
                    ]);
                    delete idxrgb[j];
                    palLen--;
                  }
                }
              }
              thold += palLen > this.colors * 3 ? this.initDist : this.distIncr;
            }
            if (palLen < this.colors) {
              sort.call(memDist, function (a, b) {
                return b[3] - a[3];
              });
              var k = 0;
              while (palLen < this.colors) {
                idxrgb[memDist[k][0]] = memDist[k][1];
                palLen++;
                k++;
              }
            }
          }
          var len = idxrgb.length;
          for (var i = 0; i < len; i++) {
            if (!idxrgb[i])
              continue;
            this.idxrgb.push(idxrgb[i]);
            this.idxi32.push(idxi32[i]);
            this.i32idx[idxi32[i]] = this.idxi32.length - 1;
            this.i32rgb[idxi32[i]] = idxrgb[i];
          }
        }
      };
      RgbQuant.prototype.colorStats1D = function colorStats1D(buf32) {
        var histG = this.histogram, num = 0, col, len = buf32.length;
        for (var i = 0; i < len; i++) {
          col = buf32[i];
          if ((col & 4278190080) >> 24 == 0)
            continue;
          if (this.hueStats)
            this.hueStats.check(col);
          if (col in histG)
            histG[col]++;
          else
            histG[col] = 1;
        }
      };
      RgbQuant.prototype.colorStats2D = function colorStats2D(buf32, width) {
        var boxW = this.boxSize[0], boxH = this.boxSize[1], area = boxW * boxH, boxes = makeBoxes(width, buf32.length / width, boxW, boxH), histG = this.histogram, self = this;
        boxes.forEach(function (box) {
          var effc = Math.max(Math.round(box.w * box.h / area) * self.boxPxls, 2), histL = {}, col;
          iterBox(box, width, function (i) {
            col = buf32[i];
            if ((col & 4278190080) >> 24 == 0)
              return;
            if (self.hueStats)
              self.hueStats.check(col);
            if (col in histG)
              histG[col]++;
            else if (col in histL) {
              if (++histL[col] >= effc)
                histG[col] = histL[col];
            } else
              histL[col] = 1;
          });
        });
        if (this.hueStats)
          this.hueStats.inject(histG);
      };
      RgbQuant.prototype.sortPal = function sortPal() {
        var self = this;
        this.idxi32.sort(function (a, b) {
          var idxA = self.i32idx[a], idxB = self.i32idx[b], rgbA = self.idxrgb[idxA], rgbB = self.idxrgb[idxB];
          var hslA = rgb2hsl(rgbA[0], rgbA[1], rgbA[2]), hslB = rgb2hsl(rgbB[0], rgbB[1], rgbB[2]);
          var hueA = rgbA[0] == rgbA[1] && rgbA[1] == rgbA[2] ? -1 : hueGroup(hslA.h, self.hueGroups);
          var hueB = rgbB[0] == rgbB[1] && rgbB[1] == rgbB[2] ? -1 : hueGroup(hslB.h, self.hueGroups);
          var hueDiff = hueB - hueA;
          if (hueDiff)
            return -hueDiff;
          var lumDiff = lumGroup(+hslB.l.toFixed(2)) - lumGroup(+hslA.l.toFixed(2));
          if (lumDiff)
            return -lumDiff;
          var satDiff = satGroup(+hslB.s.toFixed(2)) - satGroup(+hslA.s.toFixed(2));
          if (satDiff)
            return -satDiff;
        });
        this.idxi32.forEach(function (i32, i) {
          self.idxrgb[i] = self.i32rgb[i32];
          self.i32idx[i32] = i;
        });
      };
      RgbQuant.prototype.nearestColor = function nearestColor(i32) {
        var idx = this.nearestIndex(i32);
        return idx === null ? 0 : this.idxi32[idx];
      };
      RgbQuant.prototype.nearestIndex = function nearestIndex(i32) {
        if ((i32 & 4278190080) >> 24 == 0)
          return null;
        if (this.useCache && '' + i32 in this.i32idx)
          return this.i32idx[i32];
        var min = 1e3, idx, rgb = [
            i32 & 255,
            (i32 & 65280) >> 8,
            (i32 & 16711680) >> 16
          ], len = this.idxrgb.length;
        for (var i = 0; i < len; i++) {
          if (!this.idxrgb[i])
            continue;
          var dist = this.colorDist(rgb, this.idxrgb[i]);
          if (dist < min) {
            min = dist;
            idx = i;
          }
        }
        return idx;
      };
      RgbQuant.prototype.cacheHistogram = function cacheHistogram(idxi32) {
        for (var i = 0, i32 = idxi32[i]; i < idxi32.length && this.histogram[i32] >= this.cacheFreq; i32 = idxi32[i++])
          this.i32idx[i32] = this.nearestIndex(i32);
      };
      function HueStats(numGroups, minCols) {
        this.numGroups = numGroups;
        this.minCols = minCols;
        this.stats = {};
        for (var i = -1; i < numGroups; i++)
          this.stats[i] = {
            num: 0,
            cols: []
          };
        this.groupsFull = 0;
      }
      HueStats.prototype.check = function checkHue(i32) {
        if (this.groupsFull == this.numGroups + 1)
          this.check = function () {
            return;
          };
        var r = i32 & 255, g = (i32 & 65280) >> 8, b = (i32 & 16711680) >> 16, hg = r == g && g == b ? -1 : hueGroup(rgb2hsl(r, g, b).h, this.numGroups), gr = this.stats[hg], min = this.minCols;
        gr.num++;
        if (gr.num > min)
          return;
        if (gr.num == min)
          this.groupsFull++;
        if (gr.num <= min)
          this.stats[hg].cols.push(i32);
      };
      HueStats.prototype.inject = function injectHues(histG) {
        for (var i = -1; i < this.numGroups; i++) {
          if (this.stats[i].num <= this.minCols) {
            switch (typeOf(histG)) {
            case 'Array':
              this.stats[i].cols.forEach(function (col) {
                if (histG.indexOf(col) == -1)
                  histG.push(col);
              });
              break;
            case 'Object':
              this.stats[i].cols.forEach(function (col) {
                if (!histG[col])
                  histG[col] = 1;
                else
                  histG[col]++;
              });
              break;
            }
          }
        }
      };
      var Pr = .2126, Pg = .7152, Pb = .0722;
      function rgb2lum(r, g, b) {
        return Math.sqrt(Pr * r * r + Pg * g * g + Pb * b * b);
      }
      var rd = 255, gd = 255, bd = 255;
      var euclMax = Math.sqrt(Pr * rd * rd + Pg * gd * gd + Pb * bd * bd);
      function distEuclidean(rgb0, rgb1) {
        var rd = rgb1[0] - rgb0[0], gd = rgb1[1] - rgb0[1], bd = rgb1[2] - rgb0[2];
        return Math.sqrt(Pr * rd * rd + Pg * gd * gd + Pb * bd * bd) / euclMax;
      }
      var manhMax = Pr * rd + Pg * gd + Pb * bd;
      function distManhattan(rgb0, rgb1) {
        var rd = Math.abs(rgb1[0] - rgb0[0]), gd = Math.abs(rgb1[1] - rgb0[1]), bd = Math.abs(rgb1[2] - rgb0[2]);
        return (Pr * rd + Pg * gd + Pb * bd) / manhMax;
      }
      function rgb2hsl(r, g, b) {
        var max, min, h, s, l, d;
        r /= 255;
        g /= 255;
        b /= 255;
        max = Math.max(r, g, b);
        min = Math.min(r, g, b);
        l = (max + min) / 2;
        if (max == min) {
          h = s = 0;
        } else {
          d = max - min;
          s = l > .5 ? d / (2 - max - min) : d / (max + min);
          switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
            break;
          }
          h /= 6;
        }
        return {
          h: h,
          s: s,
          l: rgb2lum(r, g, b)
        };
      }
      function hueGroup(hue, segs) {
        var seg = 1 / segs, haf = seg / 2;
        if (hue >= 1 - haf || hue <= haf)
          return 0;
        for (var i = 1; i < segs; i++) {
          var mid = i * seg;
          if (hue >= mid - haf && hue <= mid + haf)
            return i;
        }
      }
      function satGroup(sat) {
        return sat;
      }
      function lumGroup(lum) {
        return lum;
      }
      function typeOf(val) {
        return Object.prototype.toString.call(val).slice(8, -1);
      }
      var sort = isArrSortStable() ? Array.prototype.sort : stableSort;
      function stableSort(fn) {
        var type = typeOf(this[0]);
        if (type == 'Number' || type == 'String') {
          var ord = {}, len = this.length, val;
          for (var i = 0; i < len; i++) {
            val = this[i];
            if (ord[val] || ord[val] === 0)
              continue;
            ord[val] = i;
          }
          return this.sort(function (a, b) {
            return fn(a, b) || ord[a] - ord[b];
          });
        } else {
          var ord = this.map(function (v) {
              return v;
            });
          return this.sort(function (a, b) {
            return fn(a, b) || ord.indexOf(a) - ord.indexOf(b);
          });
        }
      }
      function isArrSortStable() {
        var str = 'abcdefghijklmnopqrstuvwxyz';
        return 'xyzvwtursopqmnklhijfgdeabc' == str.split('').sort(function (a, b) {
          return ~~(str.indexOf(b) / 2.3) - ~~(str.indexOf(a) / 2.3);
        }).join('');
      }
      function getImageData(img, width) {
        var can, ctx, imgd, buf8, buf32, height;
        switch (typeOf(img)) {
        case 'HTMLImageElement':
          can = document.createElement('canvas');
          can.width = img.naturalWidth;
          can.height = img.naturalHeight;
          ctx = can.getContext('2d');
          ctx.drawImage(img, 0, 0);
        case 'Canvas':
        case 'HTMLCanvasElement':
          can = can || img;
          ctx = ctx || can.getContext('2d');
        case 'CanvasRenderingContext2D':
          ctx = ctx || img;
          can = can || ctx.canvas;
          imgd = ctx.getImageData(0, 0, can.width, can.height);
        case 'ImageData':
          imgd = imgd || img;
          width = imgd.width;
          if (typeOf(imgd.data) == 'CanvasPixelArray')
            buf8 = new Uint8Array(imgd.data);
          else
            buf8 = imgd.data;
        case 'Array':
        case 'CanvasPixelArray':
          buf8 = buf8 || new Uint8Array(img);
        case 'Uint8Array':
        case 'Uint8ClampedArray':
          buf8 = buf8 || img;
          buf32 = new Uint32Array(buf8.buffer);
        case 'Uint32Array':
          buf32 = buf32 || img;
          buf8 = buf8 || new Uint8Array(buf32.buffer);
          width = width || buf32.length;
          height = buf32.length / width;
        }
        return {
          can: can,
          ctx: ctx,
          imgd: imgd,
          buf8: buf8,
          buf32: buf32,
          width: width,
          height: height
        };
      }
      function makeBoxes(wid, hgt, w0, h0) {
        var wnum = ~~(wid / w0), wrem = wid % w0, hnum = ~~(hgt / h0), hrem = hgt % h0, xend = wid - wrem, yend = hgt - hrem;
        var bxs = [];
        for (var y = 0; y < hgt; y += h0)
          for (var x = 0; x < wid; x += w0)
            bxs.push({
              x: x,
              y: y,
              w: x == xend ? wrem : w0,
              h: y == yend ? hrem : h0
            });
        return bxs;
      }
      function iterBox(bbox, wid, fn) {
        var b = bbox, i0 = b.y * wid + b.x, i1 = (b.y + b.h - 1) * wid + (b.x + b.w - 1), cnt = 0, incr = wid - b.w + 1, i = i0;
        do {
          fn.call(this, i);
          i += ++cnt % b.w == 0 ? incr : 1;
        } while (i <= i1);
      }
      function sortedHashKeys(obj, desc) {
        var keys = [];
        for (var key in obj)
          keys.push(key);
        return sort.call(keys, function (a, b) {
          return desc ? obj[b] - obj[a] : obj[a] - obj[b];
        });
      }
      this.RgbQuant = RgbQuant;
      if (typeof module !== 'undefined' && module.exports) {
        module.exports = RgbQuant;
      }
    }.call(this));
  });
  require('/gif.worker.coffee');
}.call(this, this));
//# sourceMappingURL=gif.worker.js.map
// gif.worker.js 0.1.6 - https://github.com/jnordberg/gif.js
